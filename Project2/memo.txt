define
{
	文字列が含まれていれば置換するー＞望んでないものも置換されるリスクがある
	コンパイル時に置き換えられる

	単純な数値ってデファインじゃないほうがいいよね

}

constexpr
{
	ぱっと見は変数なので<T>で使える
	コンパイル時に展開される->メモリーを圧迫する事がない
}

ユニークポインタ
{
		デリーターはデストラクタ以外を指定できる
}

プログラムを書くうえで
{
		時間の流れやメンバーも意識してメンテナンスのしやすさ、分かりやすさを意識していこう
		ハードやOS、プログラム的に正しいだけを追い求めずに保守性も意識しよう
}


シングルトン
{
	一つだけ存在していて欲しい（例マネージャークラス）クラスを作れる
	人力による管理は大変、誰かが複数作ってしまう
	自由にインスタンス出来るから複数作れてしまうならば？
	動的なシングルトンと静的なシングルトンがある
	静的なシングルトンはスコープを失うまでメモリーに居る　プログラムが生きてるうちはずっと居るよ
	動的なシングルトンは初めて生成されるまでメモリーに居ない　いらなくなったら破棄することも出来る
	ユニークポインタを使って動的なんだけど破棄はユニークポインタで自動的にやる方法もある
	細かいところは様々な書き方がある

}

デストラクタ
{
		継承のオーバーロードをする場合にはvirtualを付けよう
		下から上に上がるための物ですから　下から上に上がる必要がないのであればvirtualを付けなくていいよ
}

やりたいこと
{
		はじめ
		{
				sceneを2つ
				タイトルとゲーム
				この２つをAからBへ移行
				sceneを管理するマネージャークラスがある
				トランディションもやる
		}
}

プログラムをする際の意識
{
		ミスをしたときに気付きやすいプログラムの構造を意識しよう
		{
				様々な実装方法がある中で適材適所な選択をしよう
				忘れても気づかせてくれるプログラムって最高だよね
				実行速度やメモリ、保守性を意識しつつヒューマンエラーを防ぐ仕組みも意識していこう
		}
		重要なところは明示的にしとくと見直した時とかに意図が分かりやすくない？
		重要な部分のプロテクトは意識しよう

}

映像表現
{
		最終画面に直接書きながら表現するのって大変じゃない？
		{
				レイヤー分けをして編集して
				バックバッファに最終描画をする方式の方がいいよね
		}
}

パーサー
{
		特定のファイルを読み込む機能を持った関数群
}

xml
{
		情報はノードで保存されている
		ノードの中にある細かな情報はアトリビュート、属性
		ノード　アトリビュート
		　ノードの子　アトリビュート
					ノードの子　etc...
		ってなっている


}

firstとnextの考え方　
{
		例えば　タイルセットを探したい　名前も分かってる
		first_node("tileset");
		これで初めに見つかったタイルセットが取れる
		first_node();だと何でもいいから初めのノード頂戴な
		firstは親にぶら下がっている
		nextは次の物に行く
}

初めっからぎちぎちに書くと遊びがなくてコードの変更がやりづらくなるので
ある程度の遊びは作っておこう（忘れないようにコメントを書いていこうね）

プログラムの表記のブレは視認性が落ちる
{
		色々な表記法を知らないとソースが読めなくなるので
		そこは注意
}

ファイルの読み込み
{
		各種イニシャライズでやってた方が
		ゲームループ中のストレスが減るユーザーのね
}

tmx
{
		csvデータまでたどりついて良い感じに格納したい
		{
				格納先はstd::map<std::string, std::vector<int>>
				mapは生成された時にvectorも作られる
				名前のないノードがcsvデータになっている
		}

}

すてーとパターン
{
		状態に合わせた動きをするプログラム
		状態に合わせて動いてくれるので状態を投げさえすれば
		投げてきた相手が誰であれ同じ動きをしてくれる
}
テーブル　関節参照
{
　ループさせやすくプログラムの変化を抑えられる
}
enum class 
{
		範囲forに対応してなかったが自分で
		例
		{
		static InputID begin(InputID) { return InputID::Up; };//begin関数を作る
		static InputID end(InputID) { return InputID::MAX; };//end関数を作る
		static InputID operator++(InputID& state) { return state = static_cast<InputID>(std::underlying_type<InputID>::type(state) +1)/*基底の型にして+１*/; };//++関数を作るガード処理はない
		//ガード処理をするならばclmpなりcheck式を入れるなりして丸めましょう
		static InputID operator*(const InputID& state) { return state; };//*関数を作る
		}
		関数を作ってやることで回せるようになる
		無いならば作っていこう
}

外部ファイルから読み込む利点
{
		埋め込みしてしまうと公開販売するとなるときに売り切りとは行かない
		アップデートをしていかないと行けない
		実行ファイルの更新は審査がかかるがリソースはその限りではない
		審査をスルー出来る->実行ファイル自体をリソース化してしまうこともあった
		{
				メモリの内容をファイルに落とし、サイドメモリにあげても動く
				ならばリソース化し、ファイルを展開メモリに置けばプログラムが動くよね

		}
		プログラマーが触らなくても良くなるプランナーさんやデザイナーさんが出来る
}

データを格納するときに考えることはアクセスのしやすさ使いやすさである
{
		格納するのは案外どうとでもなるので
		使いやすさを優先しよう
}

今回のアニメ―ション管理
{
内側から考えよう
		アニメ―ションIDの種類だけ欲しい map?vector?　mapの機能に投げよう
		{
				アニメ―ション,ループ回数がセットで保存しときたい  piar? array?
				アニメ―ション vector?list?大事なのはランダムアクセスします？細かく追加したりします？
				{
						ImageMng用のID 何番目なの？	描画何秒間するの？ ペアで居たい piar? array? arryだと名前付けて管理できる
						が複数個
						何個あるのか知らんよ
				}
		}
		std::map<アニメ―ションID,std::pair<ループ回数,std::list<イメージマネージャー用のID,何秒間>>>
}

キャラクターのふるまい
{
		プログラムに埋め込んでしまうと柔軟な変更ができなくなってしまう
		{
				あなたはだれ？
				{
						ノードの区分　例　MoveLR
						{
								
								モジュールがぶら下がっていく例　name Move x =-2
						}
				}
		}

}

ライブラリ
{
		別に内部を変更してもいいけれど
		サポートの対象外だし、versionが上がった時に
		変更箇所を覚えておかないといけない
}

関数オブジェクト
{
		きれいにファイル分けしやすい
		分担作業がしやすい
		依存がすこしゆるくなって使いやすい
		ラムダよりは少し早い
}
function
{
		関数を同じ引数,返り値であれば一括管理できる
}

コマンド入力
{
		例　波動拳
		{
				下斜め右右Aが対象となるコマンドですよ
				素直にこれをとっても上手くはいかないでしょう
				実際に入力で入ってきた物が↓↓↓↓↓↓　右斜め↓　右斜め↓　右斜め↓　→→→AA
				みたいに連続したフレームに素直に欲しいデータが入っているわけではない
		}
		素直に変化を記録して行くのはちょっと効率悪いよね

		トリガーとなるラストのキーから見ていく
		該当する対象から外れるとチェックを辞められる

		コマンドデータの格納（ファイル）
		{
				入力の種類(同時押しも許容したり識別したい)、猶予Fをセットで持たせていく
				または全体で猶予Fをもたせておくのもある
				（１０F以内にこのコマンドを打っておけばOK）
				合わせ技もあり
		}
		入力データのバッファ
		{
				一定時間たつと古い情報を消さないといけない
				コマンド判定し成功した入力情報群は消す
				いつ捨てるか
				{
						vectorだとメモリが汚くなるし遅くなりやすい
						list　わかりやすくやりやすくはある　インスタンスとデリートが多めかな？
						循環　リングバッファの考えを使いコマンド最大＋αぐらいのメモリを確保して
						お尻と先頭を引っ付けて回す　デバッグはデータが常時変わるからやりづらい
						ただしメモリの追加、破棄がない
						自作のリストを作って双方向リストで頭とお尻をつなげる
						自分の値が見えて前と後ろに行ければ良いだけ
				}
		}
		ガベージコレクションの発生に気を付けよう
		ゲットセットを持たせた疑似的なリングバッファだとコストがかかるがわかりやすい
		リングバッファだとアクセスがシンプルにはなるが構造の用意と開放が面倒
		{
				一度動き出すと先頭はわからなくなる
				値 next beforeがあれば良い 
		}

		キー情報の格納
		{
				同時押しってあるよね
				ビットを立ててやるのがいいかな
				unsigned int
		}
}
既定となるクラスはしっかりとcheckしよう

Draw
{
		DrawCallをよびだすたびに対象となる頂点を描画しようとします
		Draw１回あたりイメージとしては1回のレンダリングパイプラインを通る
		レンダリングパイプラインは、入力された情報ー＞画面に表示されるまでのプロセス
		[3Ｄゲーム制作者のための３Ｄグラフィックス技術]とかに詳しく書いてる
		頂点シェーダ→ラスタライザ→ピクセルシェーダ
		画面外にあるピクセルは塗りつぶさないからピクセルシェーダは走りませが、
		頂点シェーダは呼ばれます→こいつが重い

		対処：インデックス管理でも座標範囲管理でも良いので描画するべき範囲を決めておいて、それの外は描画をしない
		コツとしては画面よりもちょっと大きく範囲をとっておきましょう、スクロール時に暗黒が出てしまうまたは描画してはいけないものが見えてしまう
		例えば画面が0〜800とするなら　キャラが-自分の幅より小さいもしくは左が800より大きければ描画しない　スクロールする場合は遊びを持たせたほうがいいよね
		-３２〜３２ぐらい余裕をとっておくと画面の中しか描画しない風に出来ます

		スクロールがあると現在のカメラ範囲がどこからどこなのかを定義しておいてね
		スクロールに対応した見える範囲　キャラが移動すると見える範囲が200〜1000になったりします
		カメラの中心を定義しておいてそこから見える範囲を求め描画していきましょう

		これは3dもそうで見える範囲の外のDrawCallを減らすためのやり方でもあります。
		ただ、３Ｄは遠近法の関係上そう単純ではない「フラスタムカリング」と言います
		（視錘台カリング）　ニアファー近すぎても見えないし遠すぎても見えないよね

		多角形なら1枚で一回書いて済むポリゴンを
		クアッドのみ（現状のやり方）で多数書いている
		ー＞DrawCallが増える
		頂点を増やして多角形とし、ぽいってするとDrawCallが一回になる
		同次座標系
		|abp|
		|cdq|
		|001| = rhw なので基本は１



}




http://www.sousakuba.com/Programming/gs_near_pos_on_line.html


32*64のキャラ画像
待機
歩き　
こうげき　
jump
死亡 
落下　
